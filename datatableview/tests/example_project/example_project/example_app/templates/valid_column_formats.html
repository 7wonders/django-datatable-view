{% extends "base.html" %}

{% block content %}
    <h2>Deprecated column definition guide</h2>

    <p>
        Before version 0.9 and the ``DatatableOptions`` class it introduced, all options had to be
        specified in one big dictionary and assigned as an attribute on the view.  For simple
        datatables, this wasn't that bad, but it didn't take much to get out of control.
    </p>

    <p>
        The guiding idea of this configuration style was to allow you to name a model field and the
        table would just use its verbose name for display purposes, and the data would be read off
        of the field value.  However, if you needed a custom header or had a more complex data
        source (method, property, two concatenated field values, etc) then the column had to become
        a 2- or 3-tuple of settings.
    </p>

    <p>
        The following formats are all valid (but deprecated) ways to write a column definition on
        a ``LegacyConfigurationDatatableView`` or ``LegacyDatatableView``, via the
        <code>datatable_options</code> class attribute:
    </p>
    <pre class="brush: python">
datatable_options = {
    'columns': [
        # "concrete" field backed by the database
        'name',  # field's verbose_name will be used
        ("Name", 'name'),  # custom verbose name provided
        ("Name", 'name', 'callback_attr_name'),  # callback looked up on view
        ("Name", 'name', callback_handle),  # calback used directly

        # non-field, but backed by methods, properties, etc
        "Virtual Field",

        # "fake" virtual field whose data is generated by the view
        ("Virtual Field", None, 'callback_attr_name'),
        ("Virtual Field", None, callback_handle),
    ],
}
    </pre>

    <p>
        For concrete fields that also provide callbacks, the actual database value will be consulted
        during searches and sorts, but the table will use the return value of the callback as the
        display data.
    </p>

    <p>
        Virtual fields are useful ways to mount methods onto a table.  Consider a read-only property
        that generates its return value based on some underlying database field:
    </p>
    <pre class="brush: python">
datatable_options = {
    'columns': [
        ("Average profit", 'get_average_profit'),
    ],
}
    </pre>
    
    <p class="alert alert-warning">
        Be careful with virtual columns that might cause database queries per-row.  That doesn't
        scale very well!
    </p>
{% endblock content %}
